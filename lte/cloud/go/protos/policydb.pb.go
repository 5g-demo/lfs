// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lte/protos/policydb.proto

package protos

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protos "magma/orc8r/cloud/go/protos"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PolicyRule_TrackingType int32

const (
	PolicyRule_ONLY_OCS     PolicyRule_TrackingType = 0
	PolicyRule_ONLY_PCRF    PolicyRule_TrackingType = 1
	PolicyRule_OCS_AND_PCRF PolicyRule_TrackingType = 2
	PolicyRule_NO_TRACKING  PolicyRule_TrackingType = 3
)

var PolicyRule_TrackingType_name = map[int32]string{
	0: "ONLY_OCS",
	1: "ONLY_PCRF",
	2: "OCS_AND_PCRF",
	3: "NO_TRACKING",
}

var PolicyRule_TrackingType_value = map[string]int32{
	"ONLY_OCS":     0,
	"ONLY_PCRF":    1,
	"OCS_AND_PCRF": 2,
	"NO_TRACKING":  3,
}

func (x PolicyRule_TrackingType) String() string {
	return proto.EnumName(PolicyRule_TrackingType_name, int32(x))
}

func (PolicyRule_TrackingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{0, 0}
}

type FlowDescription_Action int32

const (
	FlowDescription_PERMIT FlowDescription_Action = 0
	FlowDescription_DENY   FlowDescription_Action = 1
)

var FlowDescription_Action_name = map[int32]string{
	0: "PERMIT",
	1: "DENY",
}

var FlowDescription_Action_value = map[string]int32{
	"PERMIT": 0,
	"DENY":   1,
}

func (x FlowDescription_Action) String() string {
	return proto.EnumName(FlowDescription_Action_name, int32(x))
}

func (FlowDescription_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{1, 0}
}

type FlowMatch_IPProto int32

const (
	FlowMatch_IPPROTO_IP       FlowMatch_IPProto = 0
	FlowMatch_IPPROTO_HOPOPTS  FlowMatch_IPProto = 0
	FlowMatch_IPPROTO_ICMP     FlowMatch_IPProto = 1
	FlowMatch_IPPROTO_IGMP     FlowMatch_IPProto = 2
	FlowMatch_IPPROTO_TCP      FlowMatch_IPProto = 6
	FlowMatch_IPPROTO_UDP      FlowMatch_IPProto = 17
	FlowMatch_IPPROTO_ROUTING  FlowMatch_IPProto = 43
	FlowMatch_IPPROTO_FRAGMENT FlowMatch_IPProto = 44
	FlowMatch_IPPROTO_GRE      FlowMatch_IPProto = 47
	FlowMatch_IPPROTO_AH       FlowMatch_IPProto = 51
	FlowMatch_IPPROTO_ICMPV6   FlowMatch_IPProto = 58
	FlowMatch_IPPROTO_NONE     FlowMatch_IPProto = 59
	FlowMatch_IPPROTO_DSTOPTS  FlowMatch_IPProto = 60
	FlowMatch_IPPROTO_OSPF     FlowMatch_IPProto = 89
	FlowMatch_IPPROTO_VRRP     FlowMatch_IPProto = 112
	FlowMatch_IPPROTO_SCTP     FlowMatch_IPProto = 132
)

var FlowMatch_IPProto_name = map[int32]string{
	0: "IPPROTO_IP",
	// Duplicate value: 0: "IPPROTO_HOPOPTS",
	1:   "IPPROTO_ICMP",
	2:   "IPPROTO_IGMP",
	6:   "IPPROTO_TCP",
	17:  "IPPROTO_UDP",
	43:  "IPPROTO_ROUTING",
	44:  "IPPROTO_FRAGMENT",
	47:  "IPPROTO_GRE",
	51:  "IPPROTO_AH",
	58:  "IPPROTO_ICMPV6",
	59:  "IPPROTO_NONE",
	60:  "IPPROTO_DSTOPTS",
	89:  "IPPROTO_OSPF",
	112: "IPPROTO_VRRP",
	132: "IPPROTO_SCTP",
}

var FlowMatch_IPProto_value = map[string]int32{
	"IPPROTO_IP":       0,
	"IPPROTO_HOPOPTS":  0,
	"IPPROTO_ICMP":     1,
	"IPPROTO_IGMP":     2,
	"IPPROTO_TCP":      6,
	"IPPROTO_UDP":      17,
	"IPPROTO_ROUTING":  43,
	"IPPROTO_FRAGMENT": 44,
	"IPPROTO_GRE":      47,
	"IPPROTO_AH":       51,
	"IPPROTO_ICMPV6":   58,
	"IPPROTO_NONE":     59,
	"IPPROTO_DSTOPTS":  60,
	"IPPROTO_OSPF":     89,
	"IPPROTO_VRRP":     112,
	"IPPROTO_SCTP":     132,
}

func (x FlowMatch_IPProto) String() string {
	return proto.EnumName(FlowMatch_IPProto_name, int32(x))
}

func (FlowMatch_IPProto) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{2, 0}
}

type FlowMatch_Direction int32

const (
	FlowMatch_UPLINK   FlowMatch_Direction = 0
	FlowMatch_DOWNLINK FlowMatch_Direction = 1
)

var FlowMatch_Direction_name = map[int32]string{
	0: "UPLINK",
	1: "DOWNLINK",
}

var FlowMatch_Direction_value = map[string]int32{
	"UPLINK":   0,
	"DOWNLINK": 1,
}

func (x FlowMatch_Direction) String() string {
	return proto.EnumName(FlowMatch_Direction_name, int32(x))
}

func (FlowMatch_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{2, 1}
}

type QosArp_PreCap int32

const (
	QosArp_PRE_CAP_ENABLED  QosArp_PreCap = 0
	QosArp_PRE_CAP_DISABLED QosArp_PreCap = 1
)

var QosArp_PreCap_name = map[int32]string{
	0: "PRE_CAP_ENABLED",
	1: "PRE_CAP_DISABLED",
}

var QosArp_PreCap_value = map[string]int32{
	"PRE_CAP_ENABLED":  0,
	"PRE_CAP_DISABLED": 1,
}

func (x QosArp_PreCap) String() string {
	return proto.EnumName(QosArp_PreCap_name, int32(x))
}

func (QosArp_PreCap) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{3, 0}
}

type QosArp_PreVul int32

const (
	QosArp_PRE_VUL_ENABLED  QosArp_PreVul = 0
	QosArp_PRE_VUL_DISABLED QosArp_PreVul = 1
)

var QosArp_PreVul_name = map[int32]string{
	0: "PRE_VUL_ENABLED",
	1: "PRE_VUL_DISABLED",
}

var QosArp_PreVul_value = map[string]int32{
	"PRE_VUL_ENABLED":  0,
	"PRE_VUL_DISABLED": 1,
}

func (x QosArp_PreVul) String() string {
	return proto.EnumName(QosArp_PreVul_name, int32(x))
}

func (QosArp_PreVul) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{3, 1}
}

type FlowQos_Qci int32

const (
	FlowQos_QCI_0  FlowQos_Qci = 0
	FlowQos_QCI_1  FlowQos_Qci = 1
	FlowQos_QCI_2  FlowQos_Qci = 2
	FlowQos_QCI_3  FlowQos_Qci = 3
	FlowQos_QCI_4  FlowQos_Qci = 4
	FlowQos_QCI_5  FlowQos_Qci = 5
	FlowQos_QCI_6  FlowQos_Qci = 6
	FlowQos_QCI_7  FlowQos_Qci = 7
	FlowQos_QCI_8  FlowQos_Qci = 8
	FlowQos_QCI_9  FlowQos_Qci = 9
	FlowQos_QCI_65 FlowQos_Qci = 65
	FlowQos_QCI_66 FlowQos_Qci = 66
	FlowQos_QCI_67 FlowQos_Qci = 67
	FlowQos_QCI_70 FlowQos_Qci = 70
	FlowQos_QCI_75 FlowQos_Qci = 75
	FlowQos_QCI_79 FlowQos_Qci = 79
)

var FlowQos_Qci_name = map[int32]string{
	0:  "QCI_0",
	1:  "QCI_1",
	2:  "QCI_2",
	3:  "QCI_3",
	4:  "QCI_4",
	5:  "QCI_5",
	6:  "QCI_6",
	7:  "QCI_7",
	8:  "QCI_8",
	9:  "QCI_9",
	65: "QCI_65",
	66: "QCI_66",
	67: "QCI_67",
	70: "QCI_70",
	75: "QCI_75",
	79: "QCI_79",
}

var FlowQos_Qci_value = map[string]int32{
	"QCI_0":  0,
	"QCI_1":  1,
	"QCI_2":  2,
	"QCI_3":  3,
	"QCI_4":  4,
	"QCI_5":  5,
	"QCI_6":  6,
	"QCI_7":  7,
	"QCI_8":  8,
	"QCI_9":  9,
	"QCI_65": 65,
	"QCI_66": 66,
	"QCI_67": 67,
	"QCI_70": 70,
	"QCI_75": 75,
	"QCI_79": 79,
}

func (x FlowQos_Qci) String() string {
	return proto.EnumName(FlowQos_Qci_name, int32(x))
}

func (FlowQos_Qci) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{4, 0}
}

type RedirectInformation_Support int32

const (
	RedirectInformation_DISABLED RedirectInformation_Support = 0
	RedirectInformation_ENABLED  RedirectInformation_Support = 1
)

var RedirectInformation_Support_name = map[int32]string{
	0: "DISABLED",
	1: "ENABLED",
}

var RedirectInformation_Support_value = map[string]int32{
	"DISABLED": 0,
	"ENABLED":  1,
}

func (x RedirectInformation_Support) String() string {
	return proto.EnumName(RedirectInformation_Support_name, int32(x))
}

func (RedirectInformation_Support) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{8, 0}
}

type RedirectInformation_AddressType int32

const (
	RedirectInformation_IPv4    RedirectInformation_AddressType = 0
	RedirectInformation_IPv6    RedirectInformation_AddressType = 1
	RedirectInformation_URL     RedirectInformation_AddressType = 2
	RedirectInformation_SIP_URI RedirectInformation_AddressType = 3
)

var RedirectInformation_AddressType_name = map[int32]string{
	0: "IPv4",
	1: "IPv6",
	2: "URL",
	3: "SIP_URI",
}

var RedirectInformation_AddressType_value = map[string]int32{
	"IPv4":    0,
	"IPv6":    1,
	"URL":     2,
	"SIP_URI": 3,
}

func (x RedirectInformation_AddressType) String() string {
	return proto.EnumName(RedirectInformation_AddressType_name, int32(x))
}

func (RedirectInformation_AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{8, 1}
}

// --------------------------------------------------------------------------
// Policy flow rules
//
// A rule is a named policy that defines a type of traffic to meter.
// Each rule has a unique human readable ID associated with the traffic
// it meters such as "All TCP Traffic to Facebook". They are classified
// using FlowMatch, and if two rules intersect, the one with the highest
// priority takes precedence. These are defined on the cloud and are streamed
// to the gateway Metering application.
//
// A match is an extensible reflection of Ryu OFPMatch which is used by rules
// to classify flows for each subscriber. For new fields and definitons see:
// http://ryu.readthedocs.io/en/latest/ofproto_v1_4_ref.html#flow-match-structure
// --------------------------------------------------------------------------
type PolicyRule struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The precedence for the flow. Same definition as 3GPP.
	Priority             uint32                  `protobuf:"varint,3,opt,name=priority,proto3" json:"priority,omitempty"`
	RatingGroup          uint32                  `protobuf:"varint,4,opt,name=rating_group,json=ratingGroup,proto3" json:"rating_group,omitempty"`
	MonitoringKey        string                  `protobuf:"bytes,6,opt,name=monitoring_key,json=monitoringKey,proto3" json:"monitoring_key,omitempty"`
	Redirect             *RedirectInformation    `protobuf:"bytes,9,opt,name=redirect,proto3" json:"redirect,omitempty"`
	FlowList             []*FlowDescription      `protobuf:"bytes,7,rep,name=flow_list,json=flowList,proto3" json:"flow_list,omitempty"`
	Qos                  *FlowQos                `protobuf:"bytes,8,opt,name=qos,proto3" json:"qos,omitempty"`
	TrackingType         PolicyRule_TrackingType `protobuf:"varint,10,opt,name=tracking_type,json=trackingType,proto3,enum=magma.lte.PolicyRule_TrackingType" json:"tracking_type,omitempty"`
	HardTimeout          uint32                  `protobuf:"varint,11,opt,name=hard_timeout,json=hardTimeout,proto3" json:"hard_timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *PolicyRule) Reset()         { *m = PolicyRule{} }
func (m *PolicyRule) String() string { return proto.CompactTextString(m) }
func (*PolicyRule) ProtoMessage()    {}
func (*PolicyRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{0}
}

func (m *PolicyRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PolicyRule.Unmarshal(m, b)
}
func (m *PolicyRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PolicyRule.Marshal(b, m, deterministic)
}
func (m *PolicyRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyRule.Merge(m, src)
}
func (m *PolicyRule) XXX_Size() int {
	return xxx_messageInfo_PolicyRule.Size(m)
}
func (m *PolicyRule) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyRule.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyRule proto.InternalMessageInfo

func (m *PolicyRule) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PolicyRule) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *PolicyRule) GetRatingGroup() uint32 {
	if m != nil {
		return m.RatingGroup
	}
	return 0
}

func (m *PolicyRule) GetMonitoringKey() string {
	if m != nil {
		return m.MonitoringKey
	}
	return ""
}

func (m *PolicyRule) GetRedirect() *RedirectInformation {
	if m != nil {
		return m.Redirect
	}
	return nil
}

func (m *PolicyRule) GetFlowList() []*FlowDescription {
	if m != nil {
		return m.FlowList
	}
	return nil
}

func (m *PolicyRule) GetQos() *FlowQos {
	if m != nil {
		return m.Qos
	}
	return nil
}

func (m *PolicyRule) GetTrackingType() PolicyRule_TrackingType {
	if m != nil {
		return m.TrackingType
	}
	return PolicyRule_ONLY_OCS
}

func (m *PolicyRule) GetHardTimeout() uint32 {
	if m != nil {
		return m.HardTimeout
	}
	return 0
}

type FlowDescription struct {
	Match                *FlowMatch             `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	Action               FlowDescription_Action `protobuf:"varint,2,opt,name=action,proto3,enum=magma.lte.FlowDescription_Action" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *FlowDescription) Reset()         { *m = FlowDescription{} }
func (m *FlowDescription) String() string { return proto.CompactTextString(m) }
func (*FlowDescription) ProtoMessage()    {}
func (*FlowDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{1}
}

func (m *FlowDescription) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FlowDescription.Unmarshal(m, b)
}
func (m *FlowDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FlowDescription.Marshal(b, m, deterministic)
}
func (m *FlowDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowDescription.Merge(m, src)
}
func (m *FlowDescription) XXX_Size() int {
	return xxx_messageInfo_FlowDescription.Size(m)
}
func (m *FlowDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowDescription.DiscardUnknown(m)
}

var xxx_messageInfo_FlowDescription proto.InternalMessageInfo

func (m *FlowDescription) GetMatch() *FlowMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *FlowDescription) GetAction() FlowDescription_Action {
	if m != nil {
		return m.Action
	}
	return FlowDescription_PERMIT
}

type FlowMatch struct {
	Ipv4Src              string              `protobuf:"bytes,1,opt,name=ipv4_src,json=ipv4Src,proto3" json:"ipv4_src,omitempty"`
	Ipv4Dst              string              `protobuf:"bytes,2,opt,name=ipv4_dst,json=ipv4Dst,proto3" json:"ipv4_dst,omitempty"`
	TcpSrc               uint32              `protobuf:"varint,3,opt,name=tcp_src,json=tcpSrc,proto3" json:"tcp_src,omitempty"`
	TcpDst               uint32              `protobuf:"varint,4,opt,name=tcp_dst,json=tcpDst,proto3" json:"tcp_dst,omitempty"`
	UdpSrc               uint32              `protobuf:"varint,5,opt,name=udp_src,json=udpSrc,proto3" json:"udp_src,omitempty"`
	UdpDst               uint32              `protobuf:"varint,6,opt,name=udp_dst,json=udpDst,proto3" json:"udp_dst,omitempty"`
	IpProto              FlowMatch_IPProto   `protobuf:"varint,7,opt,name=ip_proto,json=ipProto,proto3,enum=magma.lte.FlowMatch_IPProto" json:"ip_proto,omitempty"`
	Direction            FlowMatch_Direction `protobuf:"varint,8,opt,name=direction,proto3,enum=magma.lte.FlowMatch_Direction" json:"direction,omitempty"`
	AppName              string              `protobuf:"bytes,9,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *FlowMatch) Reset()         { *m = FlowMatch{} }
func (m *FlowMatch) String() string { return proto.CompactTextString(m) }
func (*FlowMatch) ProtoMessage()    {}
func (*FlowMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{2}
}

func (m *FlowMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FlowMatch.Unmarshal(m, b)
}
func (m *FlowMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FlowMatch.Marshal(b, m, deterministic)
}
func (m *FlowMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowMatch.Merge(m, src)
}
func (m *FlowMatch) XXX_Size() int {
	return xxx_messageInfo_FlowMatch.Size(m)
}
func (m *FlowMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowMatch.DiscardUnknown(m)
}

var xxx_messageInfo_FlowMatch proto.InternalMessageInfo

func (m *FlowMatch) GetIpv4Src() string {
	if m != nil {
		return m.Ipv4Src
	}
	return ""
}

func (m *FlowMatch) GetIpv4Dst() string {
	if m != nil {
		return m.Ipv4Dst
	}
	return ""
}

func (m *FlowMatch) GetTcpSrc() uint32 {
	if m != nil {
		return m.TcpSrc
	}
	return 0
}

func (m *FlowMatch) GetTcpDst() uint32 {
	if m != nil {
		return m.TcpDst
	}
	return 0
}

func (m *FlowMatch) GetUdpSrc() uint32 {
	if m != nil {
		return m.UdpSrc
	}
	return 0
}

func (m *FlowMatch) GetUdpDst() uint32 {
	if m != nil {
		return m.UdpDst
	}
	return 0
}

func (m *FlowMatch) GetIpProto() FlowMatch_IPProto {
	if m != nil {
		return m.IpProto
	}
	return FlowMatch_IPPROTO_IP
}

func (m *FlowMatch) GetDirection() FlowMatch_Direction {
	if m != nil {
		return m.Direction
	}
	return FlowMatch_UPLINK
}

func (m *FlowMatch) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

type QosArp struct {
	PriorityLevel        uint32        `protobuf:"varint,1,opt,name=priority_level,json=priorityLevel,proto3" json:"priority_level,omitempty"`
	PreCapability        QosArp_PreCap `protobuf:"varint,2,opt,name=pre_capability,json=preCapability,proto3,enum=magma.lte.QosArp_PreCap" json:"pre_capability,omitempty"`
	PreVulnerability     QosArp_PreVul `protobuf:"varint,3,opt,name=pre_vulnerability,json=preVulnerability,proto3,enum=magma.lte.QosArp_PreVul" json:"pre_vulnerability,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *QosArp) Reset()         { *m = QosArp{} }
func (m *QosArp) String() string { return proto.CompactTextString(m) }
func (*QosArp) ProtoMessage()    {}
func (*QosArp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{3}
}

func (m *QosArp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QosArp.Unmarshal(m, b)
}
func (m *QosArp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QosArp.Marshal(b, m, deterministic)
}
func (m *QosArp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosArp.Merge(m, src)
}
func (m *QosArp) XXX_Size() int {
	return xxx_messageInfo_QosArp.Size(m)
}
func (m *QosArp) XXX_DiscardUnknown() {
	xxx_messageInfo_QosArp.DiscardUnknown(m)
}

var xxx_messageInfo_QosArp proto.InternalMessageInfo

func (m *QosArp) GetPriorityLevel() uint32 {
	if m != nil {
		return m.PriorityLevel
	}
	return 0
}

func (m *QosArp) GetPreCapability() QosArp_PreCap {
	if m != nil {
		return m.PreCapability
	}
	return QosArp_PRE_CAP_ENABLED
}

func (m *QosArp) GetPreVulnerability() QosArp_PreVul {
	if m != nil {
		return m.PreVulnerability
	}
	return QosArp_PRE_VUL_ENABLED
}

type FlowQos struct {
	MaxReqBwUl           uint32      `protobuf:"varint,1,opt,name=max_req_bw_ul,json=maxReqBwUl,proto3" json:"max_req_bw_ul,omitempty"`
	MaxReqBwDl           uint32      `protobuf:"varint,2,opt,name=max_req_bw_dl,json=maxReqBwDl,proto3" json:"max_req_bw_dl,omitempty"`
	GbrUl                uint32      `protobuf:"varint,3,opt,name=gbr_ul,json=gbrUl,proto3" json:"gbr_ul,omitempty"`
	GbrDl                uint32      `protobuf:"varint,4,opt,name=gbr_dl,json=gbrDl,proto3" json:"gbr_dl,omitempty"`
	Qci                  FlowQos_Qci `protobuf:"varint,5,opt,name=qci,proto3,enum=magma.lte.FlowQos_Qci" json:"qci,omitempty"`
	Arp                  *QosArp     `protobuf:"bytes,6,opt,name=arp,proto3" json:"arp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FlowQos) Reset()         { *m = FlowQos{} }
func (m *FlowQos) String() string { return proto.CompactTextString(m) }
func (*FlowQos) ProtoMessage()    {}
func (*FlowQos) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{4}
}

func (m *FlowQos) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FlowQos.Unmarshal(m, b)
}
func (m *FlowQos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FlowQos.Marshal(b, m, deterministic)
}
func (m *FlowQos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowQos.Merge(m, src)
}
func (m *FlowQos) XXX_Size() int {
	return xxx_messageInfo_FlowQos.Size(m)
}
func (m *FlowQos) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowQos.DiscardUnknown(m)
}

var xxx_messageInfo_FlowQos proto.InternalMessageInfo

func (m *FlowQos) GetMaxReqBwUl() uint32 {
	if m != nil {
		return m.MaxReqBwUl
	}
	return 0
}

func (m *FlowQos) GetMaxReqBwDl() uint32 {
	if m != nil {
		return m.MaxReqBwDl
	}
	return 0
}

func (m *FlowQos) GetGbrUl() uint32 {
	if m != nil {
		return m.GbrUl
	}
	return 0
}

func (m *FlowQos) GetGbrDl() uint32 {
	if m != nil {
		return m.GbrDl
	}
	return 0
}

func (m *FlowQos) GetQci() FlowQos_Qci {
	if m != nil {
		return m.Qci
	}
	return FlowQos_QCI_0
}

func (m *FlowQos) GetArp() *QosArp {
	if m != nil {
		return m.Arp
	}
	return nil
}

type PolicyRuleData struct {
	NetworkId            *protos.NetworkID `protobuf:"bytes,1,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	Rule                 *PolicyRule       `protobuf:"bytes,2,opt,name=rule,proto3" json:"rule,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PolicyRuleData) Reset()         { *m = PolicyRuleData{} }
func (m *PolicyRuleData) String() string { return proto.CompactTextString(m) }
func (*PolicyRuleData) ProtoMessage()    {}
func (*PolicyRuleData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{5}
}

func (m *PolicyRuleData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PolicyRuleData.Unmarshal(m, b)
}
func (m *PolicyRuleData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PolicyRuleData.Marshal(b, m, deterministic)
}
func (m *PolicyRuleData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyRuleData.Merge(m, src)
}
func (m *PolicyRuleData) XXX_Size() int {
	return xxx_messageInfo_PolicyRuleData.Size(m)
}
func (m *PolicyRuleData) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyRuleData.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyRuleData proto.InternalMessageInfo

func (m *PolicyRuleData) GetNetworkId() *protos.NetworkID {
	if m != nil {
		return m.NetworkId
	}
	return nil
}

func (m *PolicyRuleData) GetRule() *PolicyRule {
	if m != nil {
		return m.Rule
	}
	return nil
}

type PolicyRuleLookup struct {
	NetworkId            *protos.NetworkID `protobuf:"bytes,1,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	RuleId               string            `protobuf:"bytes,2,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PolicyRuleLookup) Reset()         { *m = PolicyRuleLookup{} }
func (m *PolicyRuleLookup) String() string { return proto.CompactTextString(m) }
func (*PolicyRuleLookup) ProtoMessage()    {}
func (*PolicyRuleLookup) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{6}
}

func (m *PolicyRuleLookup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PolicyRuleLookup.Unmarshal(m, b)
}
func (m *PolicyRuleLookup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PolicyRuleLookup.Marshal(b, m, deterministic)
}
func (m *PolicyRuleLookup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyRuleLookup.Merge(m, src)
}
func (m *PolicyRuleLookup) XXX_Size() int {
	return xxx_messageInfo_PolicyRuleLookup.Size(m)
}
func (m *PolicyRuleLookup) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyRuleLookup.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyRuleLookup proto.InternalMessageInfo

func (m *PolicyRuleLookup) GetNetworkId() *protos.NetworkID {
	if m != nil {
		return m.NetworkId
	}
	return nil
}

func (m *PolicyRuleLookup) GetRuleId() string {
	if m != nil {
		return m.RuleId
	}
	return ""
}

type PolicyRuleSet struct {
	Rules                []*PolicyRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PolicyRuleSet) Reset()         { *m = PolicyRuleSet{} }
func (m *PolicyRuleSet) String() string { return proto.CompactTextString(m) }
func (*PolicyRuleSet) ProtoMessage()    {}
func (*PolicyRuleSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{7}
}

func (m *PolicyRuleSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PolicyRuleSet.Unmarshal(m, b)
}
func (m *PolicyRuleSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PolicyRuleSet.Marshal(b, m, deterministic)
}
func (m *PolicyRuleSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyRuleSet.Merge(m, src)
}
func (m *PolicyRuleSet) XXX_Size() int {
	return xxx_messageInfo_PolicyRuleSet.Size(m)
}
func (m *PolicyRuleSet) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyRuleSet.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyRuleSet proto.InternalMessageInfo

func (m *PolicyRuleSet) GetRules() []*PolicyRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type RedirectInformation struct {
	Support              RedirectInformation_Support     `protobuf:"varint,1,opt,name=support,proto3,enum=magma.lte.RedirectInformation_Support" json:"support,omitempty"`
	AddressType          RedirectInformation_AddressType `protobuf:"varint,2,opt,name=address_type,json=addressType,proto3,enum=magma.lte.RedirectInformation_AddressType" json:"address_type,omitempty"`
	ServerAddress        string                          `protobuf:"bytes,3,opt,name=server_address,json=serverAddress,proto3" json:"server_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *RedirectInformation) Reset()         { *m = RedirectInformation{} }
func (m *RedirectInformation) String() string { return proto.CompactTextString(m) }
func (*RedirectInformation) ProtoMessage()    {}
func (*RedirectInformation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{8}
}

func (m *RedirectInformation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RedirectInformation.Unmarshal(m, b)
}
func (m *RedirectInformation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RedirectInformation.Marshal(b, m, deterministic)
}
func (m *RedirectInformation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedirectInformation.Merge(m, src)
}
func (m *RedirectInformation) XXX_Size() int {
	return xxx_messageInfo_RedirectInformation.Size(m)
}
func (m *RedirectInformation) XXX_DiscardUnknown() {
	xxx_messageInfo_RedirectInformation.DiscardUnknown(m)
}

var xxx_messageInfo_RedirectInformation proto.InternalMessageInfo

func (m *RedirectInformation) GetSupport() RedirectInformation_Support {
	if m != nil {
		return m.Support
	}
	return RedirectInformation_DISABLED
}

func (m *RedirectInformation) GetAddressType() RedirectInformation_AddressType {
	if m != nil {
		return m.AddressType
	}
	return RedirectInformation_IPv4
}

func (m *RedirectInformation) GetServerAddress() string {
	if m != nil {
		return m.ServerAddress
	}
	return ""
}

type ChargingRuleBaseNameLookup struct {
	NetworkID            *protos.NetworkID `protobuf:"bytes,1,opt,name=NetworkID,proto3" json:"NetworkID,omitempty"`
	Name                 string            `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ChargingRuleBaseNameLookup) Reset()         { *m = ChargingRuleBaseNameLookup{} }
func (m *ChargingRuleBaseNameLookup) String() string { return proto.CompactTextString(m) }
func (*ChargingRuleBaseNameLookup) ProtoMessage()    {}
func (*ChargingRuleBaseNameLookup) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{9}
}

func (m *ChargingRuleBaseNameLookup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChargingRuleBaseNameLookup.Unmarshal(m, b)
}
func (m *ChargingRuleBaseNameLookup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChargingRuleBaseNameLookup.Marshal(b, m, deterministic)
}
func (m *ChargingRuleBaseNameLookup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChargingRuleBaseNameLookup.Merge(m, src)
}
func (m *ChargingRuleBaseNameLookup) XXX_Size() int {
	return xxx_messageInfo_ChargingRuleBaseNameLookup.Size(m)
}
func (m *ChargingRuleBaseNameLookup) XXX_DiscardUnknown() {
	xxx_messageInfo_ChargingRuleBaseNameLookup.DiscardUnknown(m)
}

var xxx_messageInfo_ChargingRuleBaseNameLookup proto.InternalMessageInfo

func (m *ChargingRuleBaseNameLookup) GetNetworkID() *protos.NetworkID {
	if m != nil {
		return m.NetworkID
	}
	return nil
}

func (m *ChargingRuleBaseNameLookup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ChargingRuleNameSet struct {
	RuleNames            []string `protobuf:"bytes,2,rep,name=RuleNames,proto3" json:"RuleNames,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChargingRuleNameSet) Reset()         { *m = ChargingRuleNameSet{} }
func (m *ChargingRuleNameSet) String() string { return proto.CompactTextString(m) }
func (*ChargingRuleNameSet) ProtoMessage()    {}
func (*ChargingRuleNameSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{10}
}

func (m *ChargingRuleNameSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChargingRuleNameSet.Unmarshal(m, b)
}
func (m *ChargingRuleNameSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChargingRuleNameSet.Marshal(b, m, deterministic)
}
func (m *ChargingRuleNameSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChargingRuleNameSet.Merge(m, src)
}
func (m *ChargingRuleNameSet) XXX_Size() int {
	return xxx_messageInfo_ChargingRuleNameSet.Size(m)
}
func (m *ChargingRuleNameSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ChargingRuleNameSet.DiscardUnknown(m)
}

var xxx_messageInfo_ChargingRuleNameSet proto.InternalMessageInfo

func (m *ChargingRuleNameSet) GetRuleNames() []string {
	if m != nil {
		return m.RuleNames
	}
	return nil
}

type ChargingRuleBaseNameRequest struct {
	Lookup               *ChargingRuleBaseNameLookup `protobuf:"bytes,1,opt,name=Lookup,proto3" json:"Lookup,omitempty"`
	Record               *ChargingRuleNameSet        `protobuf:"bytes,2,opt,name=Record,proto3" json:"Record,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ChargingRuleBaseNameRequest) Reset()         { *m = ChargingRuleBaseNameRequest{} }
func (m *ChargingRuleBaseNameRequest) String() string { return proto.CompactTextString(m) }
func (*ChargingRuleBaseNameRequest) ProtoMessage()    {}
func (*ChargingRuleBaseNameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{11}
}

func (m *ChargingRuleBaseNameRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChargingRuleBaseNameRequest.Unmarshal(m, b)
}
func (m *ChargingRuleBaseNameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChargingRuleBaseNameRequest.Marshal(b, m, deterministic)
}
func (m *ChargingRuleBaseNameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChargingRuleBaseNameRequest.Merge(m, src)
}
func (m *ChargingRuleBaseNameRequest) XXX_Size() int {
	return xxx_messageInfo_ChargingRuleBaseNameRequest.Size(m)
}
func (m *ChargingRuleBaseNameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChargingRuleBaseNameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChargingRuleBaseNameRequest proto.InternalMessageInfo

func (m *ChargingRuleBaseNameRequest) GetLookup() *ChargingRuleBaseNameLookup {
	if m != nil {
		return m.Lookup
	}
	return nil
}

func (m *ChargingRuleBaseNameRequest) GetRecord() *ChargingRuleNameSet {
	if m != nil {
		return m.Record
	}
	return nil
}

type ChargingRuleBaseNameRecord struct {
	Name                 string               `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	RuleNamesSet         *ChargingRuleNameSet `protobuf:"bytes,2,opt,name=RuleNamesSet,proto3" json:"RuleNamesSet,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ChargingRuleBaseNameRecord) Reset()         { *m = ChargingRuleBaseNameRecord{} }
func (m *ChargingRuleBaseNameRecord) String() string { return proto.CompactTextString(m) }
func (*ChargingRuleBaseNameRecord) ProtoMessage()    {}
func (*ChargingRuleBaseNameRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4a2a416c199de0d, []int{12}
}

func (m *ChargingRuleBaseNameRecord) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChargingRuleBaseNameRecord.Unmarshal(m, b)
}
func (m *ChargingRuleBaseNameRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChargingRuleBaseNameRecord.Marshal(b, m, deterministic)
}
func (m *ChargingRuleBaseNameRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChargingRuleBaseNameRecord.Merge(m, src)
}
func (m *ChargingRuleBaseNameRecord) XXX_Size() int {
	return xxx_messageInfo_ChargingRuleBaseNameRecord.Size(m)
}
func (m *ChargingRuleBaseNameRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ChargingRuleBaseNameRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ChargingRuleBaseNameRecord proto.InternalMessageInfo

func (m *ChargingRuleBaseNameRecord) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChargingRuleBaseNameRecord) GetRuleNamesSet() *ChargingRuleNameSet {
	if m != nil {
		return m.RuleNamesSet
	}
	return nil
}

func init() {
	proto.RegisterEnum("magma.lte.PolicyRule_TrackingType", PolicyRule_TrackingType_name, PolicyRule_TrackingType_value)
	proto.RegisterEnum("magma.lte.FlowDescription_Action", FlowDescription_Action_name, FlowDescription_Action_value)
	proto.RegisterEnum("magma.lte.FlowMatch_IPProto", FlowMatch_IPProto_name, FlowMatch_IPProto_value)
	proto.RegisterEnum("magma.lte.FlowMatch_Direction", FlowMatch_Direction_name, FlowMatch_Direction_value)
	proto.RegisterEnum("magma.lte.QosArp_PreCap", QosArp_PreCap_name, QosArp_PreCap_value)
	proto.RegisterEnum("magma.lte.QosArp_PreVul", QosArp_PreVul_name, QosArp_PreVul_value)
	proto.RegisterEnum("magma.lte.FlowQos_Qci", FlowQos_Qci_name, FlowQos_Qci_value)
	proto.RegisterEnum("magma.lte.RedirectInformation_Support", RedirectInformation_Support_name, RedirectInformation_Support_value)
	proto.RegisterEnum("magma.lte.RedirectInformation_AddressType", RedirectInformation_AddressType_name, RedirectInformation_AddressType_value)
	proto.RegisterType((*PolicyRule)(nil), "magma.lte.PolicyRule")
	proto.RegisterType((*FlowDescription)(nil), "magma.lte.FlowDescription")
	proto.RegisterType((*FlowMatch)(nil), "magma.lte.FlowMatch")
	proto.RegisterType((*QosArp)(nil), "magma.lte.QosArp")
	proto.RegisterType((*FlowQos)(nil), "magma.lte.FlowQos")
	proto.RegisterType((*PolicyRuleData)(nil), "magma.lte.PolicyRuleData")
	proto.RegisterType((*PolicyRuleLookup)(nil), "magma.lte.PolicyRuleLookup")
	proto.RegisterType((*PolicyRuleSet)(nil), "magma.lte.PolicyRuleSet")
	proto.RegisterType((*RedirectInformation)(nil), "magma.lte.RedirectInformation")
	proto.RegisterType((*ChargingRuleBaseNameLookup)(nil), "magma.lte.ChargingRuleBaseNameLookup")
	proto.RegisterType((*ChargingRuleNameSet)(nil), "magma.lte.ChargingRuleNameSet")
	proto.RegisterType((*ChargingRuleBaseNameRequest)(nil), "magma.lte.ChargingRuleBaseNameRequest")
	proto.RegisterType((*ChargingRuleBaseNameRecord)(nil), "magma.lte.ChargingRuleBaseNameRecord")
}

func init() {
	proto.RegisterFile("lte/protos/policydb.proto", fileDescriptor_a4a2a416c199de0d)
}

var fileDescriptor_a4a2a416c199de0d = []byte{
	// 1590 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x4f, 0x73, 0xdb, 0xc6,
	0x15, 0x27, 0x48, 0x89, 0x14, 0x1e, 0x45, 0x7a, 0xb5, 0x4e, 0x1a, 0x4a, 0xce, 0x78, 0x64, 0x34,
	0xce, 0xa8, 0x49, 0x87, 0x4a, 0x29, 0x5b, 0x8a, 0x53, 0xb7, 0x29, 0x45, 0x52, 0x0a, 0xc6, 0x14,
	0x09, 0x2d, 0x49, 0x65, 0xdc, 0x0b, 0x06, 0x02, 0xd6, 0x32, 0xc6, 0x20, 0x01, 0x2d, 0x96, 0x52,
	0x74, 0xef, 0xa9, 0xe7, 0xce, 0xb4, 0x3d, 0xf6, 0xde, 0x73, 0x2f, 0xfd, 0x24, 0xfd, 0x36, 0x9d,
	0xdd, 0x05, 0x40, 0x44, 0xa6, 0xa2, 0x38, 0x27, 0xbe, 0x7d, 0xef, 0xf7, 0x7b, 0xfb, 0xf6, 0xfd,
	0x59, 0x2c, 0x61, 0x33, 0xe0, 0x74, 0x37, 0x62, 0x21, 0x0f, 0xe3, 0xdd, 0x28, 0x0c, 0x7c, 0xf7,
	0xc6, 0x3b, 0x6f, 0xca, 0x35, 0xd6, 0xa7, 0xce, 0xc5, 0xd4, 0x69, 0x06, 0x9c, 0x6e, 0x6d, 0x86,
	0xcc, 0xfd, 0x9a, 0xa5, 0x38, 0x37, 0x9c, 0x4e, 0xc3, 0x99, 0x42, 0x19, 0xff, 0x2b, 0x01, 0x58,
	0x92, 0x48, 0xe6, 0x01, 0xc5, 0x75, 0x28, 0xfa, 0x5e, 0x43, 0xdb, 0xd6, 0x76, 0x74, 0x52, 0xf4,
	0x3d, 0xbc, 0x05, 0x6b, 0x11, 0xf3, 0x43, 0xe6, 0xf3, 0x9b, 0x46, 0x69, 0x5b, 0xdb, 0xa9, 0x91,
	0x6c, 0x8d, 0x9f, 0xc0, 0x3a, 0x73, 0xb8, 0x3f, 0xbb, 0xb0, 0x2f, 0x58, 0x38, 0x8f, 0x1a, 0x2b,
	0xd2, 0x5e, 0x55, 0xba, 0x63, 0xa1, 0xc2, 0x4f, 0xa1, 0x3e, 0x0d, 0x67, 0x3e, 0x0f, 0x99, 0x80,
	0xbd, 0xa3, 0x37, 0x8d, 0xb2, 0x74, 0x5d, 0x5b, 0x68, 0x5f, 0xd1, 0x1b, 0xfc, 0x0d, 0xac, 0x31,
	0xea, 0xf9, 0x8c, 0xba, 0xbc, 0xa1, 0x6f, 0x6b, 0x3b, 0xd5, 0xd6, 0xe3, 0x66, 0x16, 0x7d, 0x93,
	0x24, 0x26, 0x73, 0xf6, 0x26, 0x64, 0x53, 0x87, 0xfb, 0xe1, 0x8c, 0x64, 0x78, 0x7c, 0x00, 0xfa,
	0x9b, 0x20, 0xbc, 0xb6, 0x03, 0x3f, 0xe6, 0x8d, 0xca, 0x76, 0x69, 0xa7, 0xda, 0xda, 0xca, 0x91,
	0x8f, 0x82, 0xf0, 0xba, 0x4b, 0x63, 0x97, 0xf9, 0x91, 0x22, 0x0a, 0x70, 0xdf, 0x8f, 0x39, 0xfe,
	0x0c, 0x4a, 0x97, 0x61, 0xdc, 0x58, 0x93, 0xfb, 0xe1, 0x5b, 0x94, 0xd3, 0x30, 0x26, 0xc2, 0x8c,
	0x8f, 0xa1, 0xc6, 0x99, 0xe3, 0xbe, 0x13, 0xf1, 0xf3, 0x9b, 0x88, 0x36, 0x60, 0x5b, 0xdb, 0xa9,
	0xb7, 0x8c, 0x1c, 0x7e, 0x91, 0xbe, 0xe6, 0x38, 0x81, 0x8e, 0x6f, 0x22, 0x4a, 0xd6, 0x79, 0x6e,
	0x25, 0xb2, 0xf5, 0xd6, 0x61, 0x9e, 0xcd, 0xfd, 0x29, 0x0d, 0xe7, 0xbc, 0x51, 0x55, 0xd9, 0x12,
	0xba, 0xb1, 0x52, 0x19, 0x03, 0x58, 0xcf, 0x3b, 0xc0, 0xeb, 0xb0, 0x36, 0x1c, 0xf4, 0x5f, 0xdb,
	0xc3, 0xce, 0x08, 0x15, 0x70, 0x0d, 0x74, 0xb9, 0xb2, 0x3a, 0xe4, 0x08, 0x69, 0x18, 0xc1, 0xfa,
	0xb0, 0x33, 0xb2, 0xdb, 0x83, 0xae, 0xd2, 0x14, 0xf1, 0x03, 0xa8, 0x0e, 0x86, 0xf6, 0x98, 0xb4,
	0x3b, 0xaf, 0xcc, 0xc1, 0x31, 0x2a, 0x19, 0xff, 0xd0, 0xe0, 0xc1, 0xad, 0xf3, 0xe3, 0x2f, 0x60,
	0x75, 0xea, 0x70, 0xf7, 0xad, 0xac, 0x71, 0xb5, 0xf5, 0xd1, 0xad, 0x73, 0x9f, 0x08, 0x1b, 0x51,
	0x10, 0xfc, 0x02, 0xca, 0x8e, 0x2b, 0x58, 0x8d, 0xa2, 0x3c, 0xf4, 0x93, 0xbb, 0xf3, 0xda, 0x6c,
	0x4b, 0x20, 0x49, 0x08, 0xc6, 0x63, 0x28, 0x2b, 0x0d, 0x06, 0x28, 0x5b, 0x3d, 0x72, 0x62, 0x8e,
	0x51, 0x01, 0xaf, 0xc1, 0x4a, 0xb7, 0x37, 0x78, 0x8d, 0x34, 0xe3, 0xef, 0xab, 0xa0, 0x67, 0xfb,
	0xe1, 0x4d, 0x58, 0xf3, 0xa3, 0xab, 0x67, 0x76, 0xcc, 0xdc, 0xa4, 0xf7, 0x2a, 0x62, 0x3d, 0x62,
	0x6e, 0x66, 0xf2, 0x62, 0x2e, 0xa3, 0x48, 0x4c, 0xdd, 0x98, 0xe3, 0x4f, 0xa0, 0xc2, 0xdd, 0x48,
	0x92, 0x54, 0x6b, 0x96, 0xb9, 0x1b, 0x09, 0x4e, 0x62, 0x10, 0x94, 0x95, 0xcc, 0x90, 0x30, 0xe6,
	0x9e, 0x62, 0xac, 0x2a, 0xc3, 0xdc, 0x4b, 0x19, 0xc2, 0x20, 0x18, 0xe5, 0xcc, 0x20, 0x18, 0x07,
	0x62, 0x7b, 0x5b, 0x8e, 0x4a, 0xa3, 0x22, 0x93, 0xf0, 0xe9, 0xb2, 0x8c, 0x35, 0x4d, 0xcb, 0x12,
	0x18, 0x11, 0x9c, 0x14, 0xf0, 0x4b, 0xd0, 0x55, 0x83, 0x8a, 0xf4, 0xad, 0x49, 0xe6, 0xe3, 0xa5,
	0xcc, 0x6e, 0x8a, 0x22, 0x0b, 0x82, 0x38, 0xb5, 0x13, 0x45, 0xf6, 0xcc, 0x99, 0x52, 0x39, 0x10,
	0x3a, 0xa9, 0x38, 0x51, 0x34, 0x70, 0xa6, 0xd4, 0xf8, 0x4f, 0x11, 0x2a, 0xc9, 0x6e, 0xb8, 0x0e,
	0x60, 0x5a, 0x16, 0x19, 0x8e, 0x87, 0xb6, 0x69, 0xa1, 0x02, 0x7e, 0x08, 0x0f, 0xd2, 0xf5, 0x77,
	0x43, 0x6b, 0x68, 0x8d, 0x45, 0xdf, 0x20, 0x58, 0xcf, 0x40, 0x9d, 0x13, 0x4b, 0xb5, 0x4e, 0xa6,
	0x39, 0x3e, 0xb1, 0x54, 0xeb, 0xa4, 0x9a, 0x71, 0xc7, 0x42, 0xe5, 0xbc, 0x62, 0xd2, 0xb5, 0xd0,
	0x46, 0xde, 0x35, 0x19, 0x4e, 0xc6, 0xa2, 0xc1, 0xbe, 0xc4, 0x1f, 0x01, 0x4a, 0x95, 0x47, 0xa4,
	0x7d, 0x7c, 0xd2, 0x1b, 0x8c, 0xd1, 0x6f, 0xf3, 0xdc, 0x63, 0xd2, 0x43, 0xbb, 0xf9, 0x30, 0xdb,
	0xdf, 0xa1, 0x3d, 0x8c, 0xa1, 0x9e, 0x8f, 0xe8, 0x6c, 0x1f, 0x7d, 0x93, 0x8f, 0x69, 0x30, 0x1c,
	0xf4, 0xd0, 0xef, 0xf3, 0x3b, 0x76, 0x47, 0x63, 0x79, 0x98, 0x97, 0x79, 0xd8, 0x70, 0x64, 0x1d,
	0xa1, 0xd7, 0x79, 0xcd, 0x19, 0x21, 0x16, 0x8a, 0xf0, 0xc6, 0x42, 0x33, 0xea, 0x8c, 0x2d, 0xf4,
	0x17, 0x6d, 0xab, 0x88, 0x34, 0xe3, 0x29, 0xe8, 0x59, 0xae, 0x45, 0x57, 0x4e, 0xac, 0xbe, 0x39,
	0x78, 0x85, 0x0a, 0x62, 0xcc, 0xba, 0xc3, 0xef, 0x07, 0x72, 0xa5, 0x19, 0xff, 0x2a, 0x42, 0xf9,
	0x34, 0x8c, 0xdb, 0x4c, 0xde, 0x5e, 0xe9, 0x65, 0x67, 0x07, 0xf4, 0x8a, 0x06, 0xb2, 0x39, 0x6b,
	0xa4, 0x96, 0x6a, 0xfb, 0x42, 0x89, 0xbf, 0x15, 0x30, 0x6a, 0xbb, 0x4e, 0xe4, 0x9c, 0xfb, 0x81,
	0xb8, 0x29, 0xd5, 0xb8, 0x34, 0x72, 0xf5, 0x56, 0x1e, 0x9b, 0x16, 0xa3, 0x1d, 0x27, 0x12, 0x0e,
	0xc4, 0x6f, 0x02, 0xc7, 0x3d, 0xd8, 0x10, 0x0e, 0xae, 0xe6, 0xc1, 0x8c, 0xb2, 0xd4, 0x47, 0xe9,
	0x27, 0x7c, 0x9c, 0xcd, 0x03, 0x82, 0x22, 0xf9, 0xbb, 0x60, 0x18, 0x7b, 0x50, 0x56, 0xfe, 0x45,
	0xea, 0x2c, 0xd2, 0xb3, 0x3b, 0x6d, 0xcb, 0xee, 0x0d, 0xda, 0x87, 0xfd, 0x5e, 0x17, 0x15, 0x44,
	0xb1, 0x52, 0x65, 0xd7, 0x1c, 0x29, 0xad, 0x96, 0x90, 0xce, 0xe6, 0x41, 0x4a, 0x3a, 0x9b, 0xf4,
	0xdf, 0x27, 0x09, 0x65, 0x8e, 0xf4, 0xd7, 0x12, 0x54, 0x92, 0x5b, 0x12, 0x3f, 0x81, 0xda, 0xd4,
	0xf9, 0xc1, 0x66, 0xf4, 0xd2, 0x3e, 0xbf, 0xb6, 0xe7, 0x69, 0x8e, 0x60, 0xea, 0xfc, 0x40, 0xe8,
	0xe5, 0xe1, 0xf5, 0x24, 0xb8, 0x05, 0xf1, 0x02, 0x99, 0x9f, 0x1c, 0xa4, 0x1b, 0xe0, 0x8f, 0xa1,
	0x7c, 0x71, 0xce, 0x04, 0x5d, 0x8d, 0xf2, 0xea, 0xc5, 0x39, 0x9b, 0x64, 0x6a, 0x2f, 0x48, 0x06,
	0x59, 0xa8, 0xbb, 0x01, 0xde, 0x81, 0xd2, 0xa5, 0xeb, 0xcb, 0x19, 0xae, 0xb7, 0x7e, 0xf5, 0xfe,
	0xd5, 0xdd, 0x3c, 0x75, 0x7d, 0x22, 0x20, 0xf8, 0xd7, 0x50, 0x72, 0x58, 0x24, 0x87, 0xba, 0xda,
	0xda, 0x78, 0x2f, 0x99, 0x44, 0x58, 0x8d, 0xff, 0x6a, 0x50, 0x3a, 0x75, 0x7d, 0xac, 0xc3, 0xea,
	0x69, 0xc7, 0xb4, 0xbf, 0x42, 0x85, 0x54, 0xfc, 0x1d, 0xd2, 0x52, 0xb1, 0x85, 0x8a, 0xa9, 0xb8,
	0x87, 0x4a, 0xa9, 0xf8, 0x0c, 0xad, 0xa4, 0xe2, 0x73, 0xb4, 0x9a, 0x8a, 0xfb, 0xa8, 0x9c, 0x8a,
	0x07, 0xa8, 0x92, 0x8a, 0x5f, 0xa3, 0xb5, 0x54, 0x7c, 0x81, 0x74, 0xd1, 0x82, 0x12, 0xfb, 0x1c,
	0xb5, 0x33, 0x79, 0x1f, 0x1d, 0x66, 0xf2, 0x01, 0xea, 0xa4, 0xf2, 0xc1, 0x57, 0xe8, 0x28, 0x93,
	0x9f, 0xa3, 0x57, 0x99, 0xfc, 0x02, 0x0d, 0x0d, 0x06, 0xf5, 0xc5, 0x17, 0xa8, 0xeb, 0x70, 0x07,
	0x3f, 0x07, 0x98, 0x51, 0x7e, 0x1d, 0xb2, 0x77, 0x76, 0xf2, 0x31, 0xaf, 0x66, 0x59, 0x92, 0x2f,
	0x81, 0xe6, 0x40, 0x99, 0xcd, 0x2e, 0xd1, 0x13, 0xa4, 0xe9, 0xe1, 0xdf, 0xc0, 0x0a, 0x9b, 0x07,
	0x54, 0x56, 0xa7, 0xda, 0xfa, 0x78, 0xe9, 0x17, 0x8e, 0x48, 0x88, 0x71, 0x0e, 0x68, 0xa1, 0xeb,
	0x87, 0xe1, 0xbb, 0x79, 0xf4, 0x4b, 0x77, 0xfd, 0x04, 0x2a, 0xc2, 0xa5, 0xe0, 0xa8, 0xfb, 0xbd,
	0x2c, 0x96, 0xa6, 0x67, 0xbc, 0x84, 0xda, 0x62, 0x8f, 0x11, 0xe5, 0xf8, 0x4b, 0x58, 0x15, 0xa6,
	0xb8, 0xa1, 0xc9, 0xaf, 0xfc, 0x1d, 0x01, 0x2a, 0x8c, 0xf1, 0xef, 0x22, 0x3c, 0x5c, 0xf2, 0x70,
	0xc0, 0x7f, 0x82, 0x4a, 0x3c, 0x8f, 0xa2, 0x90, 0x71, 0x19, 0x62, 0xbd, 0xf5, 0xf9, 0x4f, 0xbf,
	0x34, 0x9a, 0x23, 0x85, 0x26, 0x29, 0x0d, 0x9f, 0xc0, 0xba, 0xe3, 0x79, 0x8c, 0xc6, 0xb1, 0x7a,
	0x10, 0xa8, 0x61, 0xff, 0xe2, 0x1e, 0x37, 0x6d, 0x45, 0x91, 0x0f, 0x83, 0xaa, 0xb3, 0x58, 0x88,
	0x4b, 0x26, 0xa6, 0xec, 0x8a, 0x32, 0x3b, 0xd1, 0xca, 0x09, 0xd0, 0x49, 0x4d, 0x69, 0x13, 0x9e,
	0xf1, 0x19, 0x54, 0x92, 0x48, 0xe4, 0x7d, 0x95, 0xce, 0x62, 0x01, 0x57, 0xa1, 0x92, 0x8e, 0xab,
	0x66, 0x1c, 0x40, 0x35, 0xb7, 0x91, 0xf8, 0xde, 0x9a, 0xd6, 0xd5, 0x33, 0xf5, 0xe5, 0x35, 0xad,
	0xab, 0x7d, 0xa4, 0xe1, 0x0a, 0x94, 0x26, 0xa4, 0x8f, 0x8a, 0x82, 0x38, 0x32, 0x2d, 0x7b, 0x42,
	0x4c, 0x54, 0x32, 0xde, 0xc0, 0x56, 0xe7, 0xad, 0xc3, 0x2e, 0xfc, 0xd9, 0x85, 0xc8, 0xe2, 0xa1,
	0x13, 0x53, 0xf1, 0xb5, 0x49, 0x4a, 0xfb, 0x0c, 0xf4, 0xac, 0x76, 0xf7, 0x55, 0x36, 0x13, 0x31,
	0x86, 0x15, 0xe1, 0x23, 0x29, 0xab, 0x94, 0x8d, 0x3d, 0x78, 0x98, 0xdf, 0x47, 0xe8, 0x44, 0x69,
	0x3f, 0x05, 0x3d, 0x5d, 0xc6, 0x8d, 0xe2, 0x76, 0x69, 0x47, 0x27, 0x0b, 0x85, 0xf1, 0x37, 0x0d,
	0x1e, 0x2d, 0x8b, 0x8e, 0xd0, 0xcb, 0x39, 0x8d, 0x39, 0xfe, 0x03, 0x94, 0x55, 0xa0, 0x49, 0x6c,
	0x4f, 0x73, 0xb5, 0xb8, 0xfb, 0x54, 0x24, 0x21, 0xe1, 0x7d, 0x28, 0x13, 0xea, 0x86, 0xcc, 0x4b,
	0x3a, 0xff, 0xf1, 0x1d, 0xf4, 0x24, 0x58, 0x92, 0xa0, 0x0d, 0xbe, 0x3c, 0x67, 0xca, 0x9a, 0x9d,
	0x5e, 0x5b, 0x9c, 0x1e, 0x1f, 0xc2, 0x7a, 0x76, 0xaa, 0x11, 0xe5, 0x3f, 0x73, 0xbf, 0x1f, 0x71,
	0x5a, 0xff, 0x5c, 0x05, 0xac, 0xda, 0xbd, 0x7b, 0xd8, 0x09, 0x67, 0x9c, 0x85, 0x41, 0x40, 0x19,
	0x7e, 0x01, 0x95, 0xb6, 0xe7, 0xc9, 0x37, 0xfc, 0xe6, 0xd2, 0xc1, 0x10, 0x37, 0xc3, 0xd6, 0xc6,
	0x8f, 0xaa, 0x76, 0x16, 0xfa, 0x9e, 0x51, 0xc0, 0x7f, 0x04, 0xe8, 0xd2, 0x80, 0x72, 0x2a, 0xd9,
	0x8f, 0x96, 0xb2, 0x55, 0xaa, 0x96, 0xf3, 0x5f, 0x02, 0x4c, 0x22, 0xcf, 0x49, 0xf8, 0x1f, 0xba,
	0xfb, 0xb7, 0x50, 0x39, 0xa6, 0xfc, 0xfe, 0xad, 0x97, 0x8f, 0xbb, 0x74, 0xa0, 0x8b, 0xf7, 0xbc,
	0x58, 0xc5, 0xf8, 0x8e, 0xb6, 0xdc, 0x6a, 0x2c, 0x65, 0x8f, 0x28, 0x37, 0x0a, 0xf8, 0x7b, 0x39,
	0x34, 0x69, 0xf9, 0xf0, 0xe7, 0xf7, 0x74, 0x4f, 0xd2, 0x75, 0x5b, 0xf7, 0x94, 0xcd, 0x28, 0xe0,
	0x3e, 0xd4, 0x55, 0x62, 0x33, 0xdf, 0x3f, 0xaf, 0x33, 0x97, 0x27, 0xea, 0x0c, 0xaa, 0xc7, 0x94,
	0x7f, 0xa8, 0xab, 0xfb, 0xa3, 0x34, 0xa1, 0x26, 0xf2, 0x97, 0xf2, 0xee, 0xce, 0xe1, 0xbd, 0xae,
	0x0e, 0x1f, 0xfd, 0x79, 0x53, 0x42, 0x76, 0xc5, 0xbf, 0x52, 0x37, 0x08, 0xe7, 0xde, 0xee, 0x45,
	0x98, 0xfc, 0xed, 0x3c, 0x2f, 0xcb, 0xdf, 0xbd, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x5b, 0x14,
	0xdb, 0xc5, 0xb3, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// PolicyDBControllerClient is the client API for PolicyDBController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PolicyDBControllerClient interface {
	// Adds a new policy rule to the store.
	// Throws ALREADY_EXISTS if the rule already exists.
	//
	AddRule(ctx context.Context, in *PolicyRuleData, opts ...grpc.CallOption) (*protos.Void, error)
	// Deletes an existing rule.
	// If the rule is not already present, this request is ignored.
	//
	DeleteRule(ctx context.Context, in *PolicyRuleLookup, opts ...grpc.CallOption) (*protos.Void, error)
	// Updates an existing rule.
	// Throws NOT_FOUND if the rule is missing.
	//
	UpdateRule(ctx context.Context, in *PolicyRuleData, opts ...grpc.CallOption) (*protos.Void, error)
	// Returns the PolicyRule given the id and network.
	// Throws NOT_FOUND if the subscriber is missing.
	//
	GetRule(ctx context.Context, in *PolicyRuleLookup, opts ...grpc.CallOption) (*PolicyRule, error)
	// List the rules in the store.
	//
	ListRules(ctx context.Context, in *protos.NetworkID, opts ...grpc.CallOption) (*PolicyRuleSet, error)
	// AddBaseName adds new Charging Rule Base Name Record (list of corresponding rule names)
	// or Updates an existing Record corresponding to the given network & base name
	// Returns the the existing base name if present
	//
	AddBaseName(ctx context.Context, in *ChargingRuleBaseNameRequest, opts ...grpc.CallOption) (*ChargingRuleNameSet, error)
	// Deletes an existing Charging Rule Base Name Record
	//
	DeleteBaseName(ctx context.Context, in *ChargingRuleBaseNameLookup, opts ...grpc.CallOption) (*protos.Void, error)
	// Returns the ChargingRuleBaseNameRecord given the name and network.
	//
	GetBaseName(ctx context.Context, in *ChargingRuleBaseNameLookup, opts ...grpc.CallOption) (*ChargingRuleNameSet, error)
	// List all Base Name Records in the store for a given network.
	//
	ListBaseNames(ctx context.Context, in *protos.NetworkID, opts ...grpc.CallOption) (*ChargingRuleNameSet, error)
}

type policyDBControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewPolicyDBControllerClient(cc grpc.ClientConnInterface) PolicyDBControllerClient {
	return &policyDBControllerClient{cc}
}

func (c *policyDBControllerClient) AddRule(ctx context.Context, in *PolicyRuleData, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/AddRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyDBControllerClient) DeleteRule(ctx context.Context, in *PolicyRuleLookup, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/DeleteRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyDBControllerClient) UpdateRule(ctx context.Context, in *PolicyRuleData, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/UpdateRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyDBControllerClient) GetRule(ctx context.Context, in *PolicyRuleLookup, opts ...grpc.CallOption) (*PolicyRule, error) {
	out := new(PolicyRule)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/GetRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyDBControllerClient) ListRules(ctx context.Context, in *protos.NetworkID, opts ...grpc.CallOption) (*PolicyRuleSet, error) {
	out := new(PolicyRuleSet)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/ListRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyDBControllerClient) AddBaseName(ctx context.Context, in *ChargingRuleBaseNameRequest, opts ...grpc.CallOption) (*ChargingRuleNameSet, error) {
	out := new(ChargingRuleNameSet)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/AddBaseName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyDBControllerClient) DeleteBaseName(ctx context.Context, in *ChargingRuleBaseNameLookup, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/DeleteBaseName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyDBControllerClient) GetBaseName(ctx context.Context, in *ChargingRuleBaseNameLookup, opts ...grpc.CallOption) (*ChargingRuleNameSet, error) {
	out := new(ChargingRuleNameSet)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/GetBaseName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyDBControllerClient) ListBaseNames(ctx context.Context, in *protos.NetworkID, opts ...grpc.CallOption) (*ChargingRuleNameSet, error) {
	out := new(ChargingRuleNameSet)
	err := c.cc.Invoke(ctx, "/magma.lte.PolicyDBController/ListBaseNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PolicyDBControllerServer is the server API for PolicyDBController service.
type PolicyDBControllerServer interface {
	// Adds a new policy rule to the store.
	// Throws ALREADY_EXISTS if the rule already exists.
	//
	AddRule(context.Context, *PolicyRuleData) (*protos.Void, error)
	// Deletes an existing rule.
	// If the rule is not already present, this request is ignored.
	//
	DeleteRule(context.Context, *PolicyRuleLookup) (*protos.Void, error)
	// Updates an existing rule.
	// Throws NOT_FOUND if the rule is missing.
	//
	UpdateRule(context.Context, *PolicyRuleData) (*protos.Void, error)
	// Returns the PolicyRule given the id and network.
	// Throws NOT_FOUND if the subscriber is missing.
	//
	GetRule(context.Context, *PolicyRuleLookup) (*PolicyRule, error)
	// List the rules in the store.
	//
	ListRules(context.Context, *protos.NetworkID) (*PolicyRuleSet, error)
	// AddBaseName adds new Charging Rule Base Name Record (list of corresponding rule names)
	// or Updates an existing Record corresponding to the given network & base name
	// Returns the the existing base name if present
	//
	AddBaseName(context.Context, *ChargingRuleBaseNameRequest) (*ChargingRuleNameSet, error)
	// Deletes an existing Charging Rule Base Name Record
	//
	DeleteBaseName(context.Context, *ChargingRuleBaseNameLookup) (*protos.Void, error)
	// Returns the ChargingRuleBaseNameRecord given the name and network.
	//
	GetBaseName(context.Context, *ChargingRuleBaseNameLookup) (*ChargingRuleNameSet, error)
	// List all Base Name Records in the store for a given network.
	//
	ListBaseNames(context.Context, *protos.NetworkID) (*ChargingRuleNameSet, error)
}

// UnimplementedPolicyDBControllerServer can be embedded to have forward compatible implementations.
type UnimplementedPolicyDBControllerServer struct {
}

func (*UnimplementedPolicyDBControllerServer) AddRule(ctx context.Context, req *PolicyRuleData) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (*UnimplementedPolicyDBControllerServer) DeleteRule(ctx context.Context, req *PolicyRuleLookup) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRule not implemented")
}
func (*UnimplementedPolicyDBControllerServer) UpdateRule(ctx context.Context, req *PolicyRuleData) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRule not implemented")
}
func (*UnimplementedPolicyDBControllerServer) GetRule(ctx context.Context, req *PolicyRuleLookup) (*PolicyRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (*UnimplementedPolicyDBControllerServer) ListRules(ctx context.Context, req *protos.NetworkID) (*PolicyRuleSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRules not implemented")
}
func (*UnimplementedPolicyDBControllerServer) AddBaseName(ctx context.Context, req *ChargingRuleBaseNameRequest) (*ChargingRuleNameSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBaseName not implemented")
}
func (*UnimplementedPolicyDBControllerServer) DeleteBaseName(ctx context.Context, req *ChargingRuleBaseNameLookup) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBaseName not implemented")
}
func (*UnimplementedPolicyDBControllerServer) GetBaseName(ctx context.Context, req *ChargingRuleBaseNameLookup) (*ChargingRuleNameSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaseName not implemented")
}
func (*UnimplementedPolicyDBControllerServer) ListBaseNames(ctx context.Context, req *protos.NetworkID) (*ChargingRuleNameSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBaseNames not implemented")
}

func RegisterPolicyDBControllerServer(s *grpc.Server, srv PolicyDBControllerServer) {
	s.RegisterService(&_PolicyDBController_serviceDesc, srv)
}

func _PolicyDBController_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyRuleData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/AddRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).AddRule(ctx, req.(*PolicyRuleData))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyDBController_DeleteRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyRuleLookup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).DeleteRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/DeleteRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).DeleteRule(ctx, req.(*PolicyRuleLookup))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyDBController_UpdateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyRuleData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).UpdateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/UpdateRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).UpdateRule(ctx, req.(*PolicyRuleData))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyDBController_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyRuleLookup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/GetRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).GetRule(ctx, req.(*PolicyRuleLookup))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyDBController_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.NetworkID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/ListRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).ListRules(ctx, req.(*protos.NetworkID))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyDBController_AddBaseName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChargingRuleBaseNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).AddBaseName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/AddBaseName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).AddBaseName(ctx, req.(*ChargingRuleBaseNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyDBController_DeleteBaseName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChargingRuleBaseNameLookup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).DeleteBaseName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/DeleteBaseName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).DeleteBaseName(ctx, req.(*ChargingRuleBaseNameLookup))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyDBController_GetBaseName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChargingRuleBaseNameLookup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).GetBaseName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/GetBaseName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).GetBaseName(ctx, req.(*ChargingRuleBaseNameLookup))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyDBController_ListBaseNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.NetworkID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyDBControllerServer).ListBaseNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.lte.PolicyDBController/ListBaseNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyDBControllerServer).ListBaseNames(ctx, req.(*protos.NetworkID))
	}
	return interceptor(ctx, in, info, handler)
}

var _PolicyDBController_serviceDesc = grpc.ServiceDesc{
	ServiceName: "magma.lte.PolicyDBController",
	HandlerType: (*PolicyDBControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRule",
			Handler:    _PolicyDBController_AddRule_Handler,
		},
		{
			MethodName: "DeleteRule",
			Handler:    _PolicyDBController_DeleteRule_Handler,
		},
		{
			MethodName: "UpdateRule",
			Handler:    _PolicyDBController_UpdateRule_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _PolicyDBController_GetRule_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _PolicyDBController_ListRules_Handler,
		},
		{
			MethodName: "AddBaseName",
			Handler:    _PolicyDBController_AddBaseName_Handler,
		},
		{
			MethodName: "DeleteBaseName",
			Handler:    _PolicyDBController_DeleteBaseName_Handler,
		},
		{
			MethodName: "GetBaseName",
			Handler:    _PolicyDBController_GetBaseName_Handler,
		},
		{
			MethodName: "ListBaseNames",
			Handler:    _PolicyDBController_ListBaseNames_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lte/protos/policydb.proto",
}
